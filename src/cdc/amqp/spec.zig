//////////////////////////////////////////////////////////
// This file was auto-generated by spec_parser.py       //
//              Do not manually modify.                 //
//////////////////////////////////////////////////////////

const std = @import("std");
const stdx = @import("../../stdx.zig");
const protocol = @import("protocol.zig");
const Decoder = protocol.Decoder;
const Encoder = protocol.Encoder;
const MethodHeader = protocol.MethodHeader;

pub const FRAME_METHOD = 1;
pub const FRAME_HEADER = 2;
pub const FRAME_BODY = 3;
pub const FRAME_HEARTBEAT = 8;
pub const FRAME_MIN_SIZE = 4096;
pub const FRAME_END = 206;
/// Indicates that the method completed successfully. This reply code is
/// reserved for future use - the current protocol design does not use positive
/// confirmation and reply codes are sent only in case of an error.
pub const REPLY_SUCCESS = 200;
/// The client attempted to transfer content larger than the server could accept
/// at the present time. The client may retry at a later time.
pub const SOFT_ERROR_CONTENT_TOO_LARGE = 311;
/// Returned when RabbitMQ sends back with 'basic.return' when a
/// 'mandatory' message cannot be delivered to any queue.
pub const SOFT_ERROR_NO_ROUTE = 312;
/// When the exchange cannot deliver to a consumer when the immediate flag is
/// set. As a result of pending data on the queue or the absence of any
/// consumers of the queue.
pub const SOFT_ERROR_NO_CONSUMERS = 313;
/// An operator intervened to close the connection for some reason. The client
/// may retry at some later date.
pub const HARD_ERROR_CONNECTION_FORCED = 320;
/// The client tried to work with an unknown virtual host.
pub const HARD_ERROR_INVALID_PATH = 402;
/// The client attempted to work with a server entity to which it has no
/// access due to security settings.
pub const SOFT_ERROR_ACCESS_REFUSED = 403;
/// The client attempted to work with a server entity that does not exist.
pub const SOFT_ERROR_NOT_FOUND = 404;
/// The client attempted to work with a server entity to which it has no
/// access because another client is working with it.
pub const SOFT_ERROR_RESOURCE_LOCKED = 405;
/// The client requested a method that was not allowed because some precondition
/// failed.
pub const SOFT_ERROR_PRECONDITION_FAILED = 406;
/// The sender sent a malformed frame that the recipient could not decode.
/// This strongly implies a programming error in the sending peer.
pub const HARD_ERROR_FRAME_ERROR = 501;
/// The sender sent a frame that contained illegal values for one or more
/// fields. This strongly implies a programming error in the sending peer.
pub const HARD_ERROR_SYNTAX_ERROR = 502;
/// The client sent an invalid sequence of frames, attempting to perform an
/// operation that was considered invalid by the server. This usually implies
/// a programming error in the client.
pub const HARD_ERROR_COMMAND_INVALID = 503;
/// The client attempted to work with a channel that had not been correctly
/// opened. This most likely indicates a fault in the client layer.
pub const HARD_ERROR_CHANNEL_ERROR = 504;
/// The peer sent a frame that was not expected, usually in the context of
/// a content header and body.  This strongly indicates a fault in the peer's
/// content processing.
pub const HARD_ERROR_UNEXPECTED_FRAME = 505;
/// The server could not complete the method because it lacked sufficient
/// resources. This may be due to the client creating too many of some type
/// of entity.
pub const HARD_ERROR_RESOURCE_ERROR = 506;
/// The client tried to work with some entity in a manner that is prohibited
/// by the server, due to security settings or by some other criteria.
pub const HARD_ERROR_NOT_ALLOWED = 530;
/// The client tried to use functionality that is not implemented in the
/// server.
pub const HARD_ERROR_NOT_IMPLEMENTED = 540;
/// The server could not complete the method because of an internal error.
/// The server may require intervention by an operator in order to resume
/// normal operations.
pub const HARD_ERROR_INTERNAL_ERROR = 541;

/// Methods sent by the AMQP server that must be handled by the client side,
/// marked by the spec with `<chassis name="client" implement="MUST|MAY"/>`.
pub const ClientMethod = union(ClientMethod.Tag) {
    pub const Tag = enum(u32) {
        connection_start = @bitCast(MethodHeader{ .class = 10, .method = 10 }),
        connection_secure = @bitCast(MethodHeader{ .class = 10, .method = 20 }),
        connection_tune = @bitCast(MethodHeader{ .class = 10, .method = 30 }),
        connection_open_ok = @bitCast(MethodHeader{ .class = 10, .method = 41 }),
        connection_close = @bitCast(MethodHeader{ .class = 10, .method = 50 }),
        connection_close_ok = @bitCast(MethodHeader{ .class = 10, .method = 51 }),
        connection_blocked = @bitCast(MethodHeader{ .class = 10, .method = 60 }),
        connection_unblocked = @bitCast(MethodHeader{ .class = 10, .method = 61 }),
        connection_update_secret = @bitCast(MethodHeader{ .class = 10, .method = 70 }),
        channel_open_ok = @bitCast(MethodHeader{ .class = 20, .method = 11 }),
        channel_flow = @bitCast(MethodHeader{ .class = 20, .method = 20 }),
        channel_flow_ok = @bitCast(MethodHeader{ .class = 20, .method = 21 }),
        channel_close = @bitCast(MethodHeader{ .class = 20, .method = 40 }),
        channel_close_ok = @bitCast(MethodHeader{ .class = 20, .method = 41 }),
        exchange_declare_ok = @bitCast(MethodHeader{ .class = 40, .method = 11 }),
        exchange_delete_ok = @bitCast(MethodHeader{ .class = 40, .method = 21 }),
        exchange_bind_ok = @bitCast(MethodHeader{ .class = 40, .method = 31 }),
        exchange_unbind_ok = @bitCast(MethodHeader{ .class = 40, .method = 51 }),
        queue_declare_ok = @bitCast(MethodHeader{ .class = 50, .method = 11 }),
        queue_bind_ok = @bitCast(MethodHeader{ .class = 50, .method = 21 }),
        queue_unbind_ok = @bitCast(MethodHeader{ .class = 50, .method = 51 }),
        queue_purge_ok = @bitCast(MethodHeader{ .class = 50, .method = 31 }),
        queue_delete_ok = @bitCast(MethodHeader{ .class = 50, .method = 41 }),
        basic_qos_ok = @bitCast(MethodHeader{ .class = 60, .method = 11 }),
        basic_consume_ok = @bitCast(MethodHeader{ .class = 60, .method = 21 }),
        basic_cancel = @bitCast(MethodHeader{ .class = 60, .method = 30 }),
        basic_cancel_ok = @bitCast(MethodHeader{ .class = 60, .method = 31 }),
        basic_return = @bitCast(MethodHeader{ .class = 60, .method = 50 }),
        basic_deliver = @bitCast(MethodHeader{ .class = 60, .method = 60 }),
        basic_get_ok = @bitCast(MethodHeader{ .class = 60, .method = 71 }),
        basic_get_empty = @bitCast(MethodHeader{ .class = 60, .method = 72 }),
        basic_ack = @bitCast(MethodHeader{ .class = 60, .method = 80 }),
        basic_recover_ok = @bitCast(MethodHeader{ .class = 60, .method = 111 }),
        basic_nack = @bitCast(MethodHeader{ .class = 60, .method = 120 }),
        tx_select_ok = @bitCast(MethodHeader{ .class = 90, .method = 11 }),
        tx_commit_ok = @bitCast(MethodHeader{ .class = 90, .method = 21 }),
        tx_rollback_ok = @bitCast(MethodHeader{ .class = 90, .method = 31 }),
        confirm_select_ok = @bitCast(MethodHeader{ .class = 85, .method = 11 }),
    };

    /// Start connection negotiation.
    /// This method starts the connection negotiation process by telling the client the
    /// protocol version that the server proposes, along with a list of security mechanisms
    /// which the client can use for authentication.
    connection_start: struct {
        /// Protocol major version.
        /// The major version number can take any value from 0 to 99 as defined in the
        /// AMQP specification.
        version_major: u8,
        /// Protocol minor version.
        /// The minor version number can take any value from 0 to 99 as defined in the
        /// AMQP specification.
        version_minor: u8,
        /// Server properties.
        server_properties: Decoder.Table,
        /// Available security mechanisms.
        /// A list of the security mechanisms that the server supports, delimited by spaces.
        mechanisms: []const u8,
        /// Available message locales.
        /// A list of the message locales that the server supports, delimited by spaces. The
        /// locale defines the language in which the server will send reply texts.
        locales: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const version_major = try decoder.read_int(u8);
            const version_minor = try decoder.read_int(u8);
            const server_properties = try decoder.read_table();
            const mechanisms = try decoder.read_long_string();
            const locales = try decoder.read_long_string();

            return .{
                .version_major = version_major,
                .version_minor = version_minor,
                .server_properties = server_properties,
                .mechanisms = mechanisms,
                .locales = locales,
            };
        }
    },
    /// Security mechanism challenge.
    /// The SASL protocol works by exchanging challenges and responses until both peers have
    /// received sufficient information to authenticate each other. This method challenges
    /// the client to provide more information.
    connection_secure: struct {
        /// Security challenge data.
        /// Challenge information, a block of opaque binary data passed to the security
        /// mechanism.
        challenge: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const challenge = try decoder.read_long_string();

            return .{
                .challenge = challenge,
            };
        }
    },
    /// Propose connection tuning parameters.
    /// This method proposes a set of connection configuration values to the client. The
    /// client can accept and/or adjust these.
    connection_tune: struct {
        /// Proposed maximum channels.
        /// Specifies highest channel number that the server permits.  Usable channel numbers
        /// are in the range 1..channel-max.  Zero indicates no specified limit.
        channel_max: u16,
        /// Proposed maximum frame size.
        /// The largest frame size that the server proposes for the connection, including
        /// frame header and end-byte.  The client can negotiate a lower value. Zero means
        /// that the server does not impose any specific limit but may reject very large
        /// frames if it cannot allocate resources for them.
        frame_max: u32,
        /// Desired heartbeat delay.
        /// The delay, in seconds, of the connection heartbeat that the server wants.
        /// Zero means the server does not want a heartbeat.
        heartbeat: u16,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const channel_max = try decoder.read_int(u16);
            const frame_max = try decoder.read_int(u32);
            const heartbeat = try decoder.read_int(u16);

            return .{
                .channel_max = channel_max,
                .frame_max = frame_max,
                .heartbeat = heartbeat,
            };
        }
    },
    /// Signal that connection is ready.
    /// This method signals to the client that the connection is ready for use.
    connection_open_ok: struct {
        reserved_1: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reserved_1 = try decoder.read_short_string();

            return .{
                .reserved_1 = reserved_1,
            };
        }
    },
    /// Request a connection close.
    /// This method indicates that the sender wants to close the connection. This may be
    /// due to internal conditions (e.g. a forced shut-down) or due to an error handling
    /// a specific method, i.e. an exception. When a close is due to an exception, the
    /// sender provides the class and method id of the method which caused the exception.
    connection_close: struct {
        reply_code: u16,
        reply_text: []const u8,
        /// Failing method class.
        /// When the close is provoked by a method exception, this is the class of the
        /// method.
        class_id: u16,
        /// Failing method id.
        /// When the close is provoked by a method exception, this is the ID of the method.
        method_id: u16,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reply_code = try decoder.read_int(u16);
            const reply_text = try decoder.read_short_string();
            const class_id = try decoder.read_int(u16);
            const method_id = try decoder.read_int(u16);

            return .{
                .reply_code = reply_code,
                .reply_text = reply_text,
                .class_id = class_id,
                .method_id = method_id,
            };
        }
    },
    /// Confirm a connection close.
    /// This method confirms a Connection.Close method and tells the recipient that it is
    /// safe to release resources for the connection and close the socket.
    connection_close_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Indicate that connection is blocked.
    /// This method indicates that a connection has been blocked
    /// and does not accept new publishes.
    connection_blocked: struct {
        /// Block reason.
        /// The reason the connection was blocked.
        reason: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reason = try decoder.read_short_string();

            return .{
                .reason = reason,
            };
        }
    },
    /// Indicate that connection is unblocked.
    /// This method indicates that a connection has been unblocked
    /// and now accepts publishes.
    connection_unblocked: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Update secret.
    /// This method updates the secret used to authenticate this connection. It is used
    /// when secrets have an expiration date and need to be renewed, like OAuth 2 tokens.
    connection_update_secret: struct {
        /// New secret.
        /// The new secret.
        new_secret: []const u8,
        /// Reason.
        /// The reason for the secret update.
        reason: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const new_secret = try decoder.read_long_string();
            const reason = try decoder.read_short_string();

            return .{
                .new_secret = new_secret,
                .reason = reason,
            };
        }
    },
    /// Signal that the channel is ready.
    /// This method signals to the client that the channel is ready for use.
    channel_open_ok: struct {
        reserved_1: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reserved_1 = try decoder.read_long_string();

            return .{
                .reserved_1 = reserved_1,
            };
        }
    },
    /// Enable/disable flow from peer.
    /// This method asks the peer to pause or restart the flow of content data sent by
    /// a consumer. This is a simple flow-control mechanism that a peer can use to avoid
    /// overflowing its queues or otherwise finding itself receiving more messages than
    /// it can process. Note that this method is not intended for window control. It does
    /// not affect contents returned by Basic.Get-Ok methods.
    channel_flow: struct {
        /// Start/stop content frames.
        /// If 1, the peer starts sending content frames. If 0, the peer stops sending
        /// content frames.
        active: bool,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const active = bitset_1.is_set(0);

            return .{
                .active = active,
            };
        }
    },
    /// Confirm a flow method.
    /// Confirms to the peer that a flow command was received and processed.
    channel_flow_ok: struct {
        /// Current flow setting.
        /// Confirms the setting of the processed flow method: 1 means the peer will start
        /// sending or continue to send content frames; 0 means it will not.
        active: bool,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const active = bitset_1.is_set(0);

            return .{
                .active = active,
            };
        }
    },
    /// Request a channel close.
    /// This method indicates that the sender wants to close the channel. This may be due to
    /// internal conditions (e.g. a forced shut-down) or due to an error handling a specific
    /// method, i.e. an exception. When a close is due to an exception, the sender provides
    /// the class and method id of the method which caused the exception.
    channel_close: struct {
        reply_code: u16,
        reply_text: []const u8,
        /// Failing method class.
        /// When the close is provoked by a method exception, this is the class of the
        /// method.
        class_id: u16,
        /// Failing method id.
        /// When the close is provoked by a method exception, this is the ID of the method.
        method_id: u16,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reply_code = try decoder.read_int(u16);
            const reply_text = try decoder.read_short_string();
            const class_id = try decoder.read_int(u16);
            const method_id = try decoder.read_int(u16);

            return .{
                .reply_code = reply_code,
                .reply_text = reply_text,
                .class_id = class_id,
                .method_id = method_id,
            };
        }
    },
    /// Confirm a channel close.
    /// This method confirms a Channel.Close method and tells the recipient that it is safe
    /// to release resources for the channel.
    channel_close_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm exchange declaration.
    /// This method confirms a Declare method and confirms the name of the exchange,
    /// essential for automatically-named exchanges.
    exchange_declare_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm deletion of an exchange.
    /// This method confirms the deletion of an exchange.
    exchange_delete_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm bind successful.
    /// This method confirms that the bind was successful.
    exchange_bind_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm unbind successful.
    /// This method confirms that the unbind was successful.
    exchange_unbind_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirms a queue definition.
    /// This method confirms a Declare method and confirms the name of the queue, essential
    /// for automatically-named queues.
    queue_declare_ok: struct {
        /// Reports the name of the queue. If the server generated a queue name, this field
        /// contains that name.
        queue: []const u8,
        message_count: u32,
        /// Number of consumers.
        /// Reports the number of active consumers for the queue. Note that consumers can
        /// suspend activity (Channel.Flow) in which case they do not appear in this count.
        consumer_count: u32,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const queue = try decoder.read_short_string();
            const message_count = try decoder.read_int(u32);
            const consumer_count = try decoder.read_int(u32);

            return .{
                .queue = queue,
                .message_count = message_count,
                .consumer_count = consumer_count,
            };
        }
    },
    /// Confirm bind successful.
    /// This method confirms that the bind was successful.
    queue_bind_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm unbind successful.
    /// This method confirms that the unbind was successful.
    queue_unbind_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirms a queue purge.
    /// This method confirms the purge of a queue.
    queue_purge_ok: struct {
        /// Reports the number of messages purged.
        message_count: u32,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const message_count = try decoder.read_int(u32);

            return .{
                .message_count = message_count,
            };
        }
    },
    /// Confirm deletion of a queue.
    /// This method confirms the deletion of a queue.
    queue_delete_ok: struct {
        /// Reports the number of messages deleted.
        message_count: u32,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const message_count = try decoder.read_int(u32);

            return .{
                .message_count = message_count,
            };
        }
    },
    /// Confirm the requested qos.
    /// This method tells the client that the requested QoS levels could be handled by the
    /// server. The requested QoS applies to all active consumers until a new QoS is
    /// defined.
    basic_qos_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm a new consumer.
    /// The server provides the client with a consumer tag, which is used by the client
    /// for methods called on the consumer at a later stage.
    basic_consume_ok: struct {
        /// Holds the consumer tag specified by the client or provided by the server.
        consumer_tag: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const consumer_tag = try decoder.read_short_string();

            return .{
                .consumer_tag = consumer_tag,
            };
        }
    },
    /// End a queue consumer.
    /// This method cancels a consumer. This does not affect already delivered
    /// messages, but it does mean the server will not send any more messages for
    /// that consumer. The client may receive an arbitrary number of messages in
    /// between sending the cancel method and receiving the cancel-ok reply.
    /// It may also be sent from the server to the client in the event
    /// of the consumer being unexpectedly cancelled (i.e. cancelled
    /// for any reason other than the server receiving the
    /// corresponding basic.cancel from the client). This allows
    /// clients to be notified of the loss of consumers due to events
    /// such as queue deletion. Note that as it is not a MUST for
    /// clients to accept this method from the server, it is advisable
    /// for the broker to be able to identify those clients that are
    /// capable of accepting the method, through some means of
    /// capability negotiation.
    basic_cancel: struct {
        consumer_tag: []const u8,
        no_wait: bool,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const consumer_tag = try decoder.read_short_string();
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const no_wait = bitset_1.is_set(0);

            return .{
                .consumer_tag = consumer_tag,
                .no_wait = no_wait,
            };
        }
    },
    /// Confirm a cancelled consumer.
    /// This method confirms that the cancellation was completed.
    basic_cancel_ok: struct {
        consumer_tag: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const consumer_tag = try decoder.read_short_string();

            return .{
                .consumer_tag = consumer_tag,
            };
        }
    },
    /// Return a failed message.
    /// This method returns an undeliverable message that was published with the "immediate"
    /// flag set, or an unroutable message published with the "mandatory" flag set. The
    /// reply code and text provide information about the reason that the message was
    /// undeliverable.
    basic_return: struct {
        reply_code: u16,
        reply_text: []const u8,
        /// Specifies the name of the exchange that the message was originally published
        /// to.  May be empty, meaning the default exchange.
        exchange: []const u8,
        /// Message routing key.
        /// Specifies the routing key name specified when the message was published.
        routing_key: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reply_code = try decoder.read_int(u16);
            const reply_text = try decoder.read_short_string();
            const exchange = try decoder.read_short_string();
            const routing_key = try decoder.read_short_string();

            return .{
                .reply_code = reply_code,
                .reply_text = reply_text,
                .exchange = exchange,
                .routing_key = routing_key,
            };
        }
    },
    /// Notify the client of a consumer message.
    /// This method delivers a message to the client, via a consumer. In the asynchronous
    /// message delivery model, the client starts a consumer using the Consume method, then
    /// the server responds with Deliver methods as and when messages arrive for that
    /// consumer.
    basic_deliver: struct {
        consumer_tag: []const u8,
        delivery_tag: u64,
        redelivered: bool,
        /// Specifies the name of the exchange that the message was originally published to.
        /// May be empty, indicating the default exchange.
        exchange: []const u8,
        /// Message routing key.
        /// Specifies the routing key name specified when the message was published.
        routing_key: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const consumer_tag = try decoder.read_short_string();
            const delivery_tag = try decoder.read_int(u64);
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const redelivered = bitset_1.is_set(0);
            const exchange = try decoder.read_short_string();
            const routing_key = try decoder.read_short_string();

            return .{
                .consumer_tag = consumer_tag,
                .delivery_tag = delivery_tag,
                .redelivered = redelivered,
                .exchange = exchange,
                .routing_key = routing_key,
            };
        }
    },
    /// Provide client with a message.
    /// This method delivers a message to the client following a get method. A message
    /// delivered by 'get-ok' must be acknowledged unless the no-ack option was set in the
    /// get method.
    basic_get_ok: struct {
        delivery_tag: u64,
        redelivered: bool,
        /// Specifies the name of the exchange that the message was originally published to.
        /// If empty, the message was published to the default exchange.
        exchange: []const u8,
        /// Message routing key.
        /// Specifies the routing key name specified when the message was published.
        routing_key: []const u8,
        message_count: u32,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const delivery_tag = try decoder.read_int(u64);
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const redelivered = bitset_1.is_set(0);
            const exchange = try decoder.read_short_string();
            const routing_key = try decoder.read_short_string();
            const message_count = try decoder.read_int(u32);

            return .{
                .delivery_tag = delivery_tag,
                .redelivered = redelivered,
                .exchange = exchange,
                .routing_key = routing_key,
                .message_count = message_count,
            };
        }
    },
    /// Indicate no messages available.
    /// This method tells the client that the queue has no messages available for the
    /// client.
    basic_get_empty: struct {
        reserved_1: []const u8,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const reserved_1 = try decoder.read_short_string();

            return .{
                .reserved_1 = reserved_1,
            };
        }
    },
    /// Acknowledge one or more messages.
    /// When sent by the client, this method acknowledges one or more
    /// messages delivered via the Deliver or Get-Ok methods.
    /// When sent by server, this method acknowledges one or more
    /// messages published with the Publish method on a channel in
    /// confirm mode.
    /// The acknowledgement can be for a single message or a set of
    /// messages up to and including a specific message.
    basic_ack: struct {
        delivery_tag: u64,
        /// Acknowledge multiple messages.
        /// If set to 1, the delivery tag is treated as "up to and
        /// including", so that multiple messages can be acknowledged
        /// with a single method. If set to zero, the delivery tag
        /// refers to a single message. If the multiple field is 1, and
        /// the delivery tag is zero, this indicates acknowledgement of
        /// all outstanding messages.
        multiple: bool,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const delivery_tag = try decoder.read_int(u64);
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const multiple = bitset_1.is_set(0);

            return .{
                .delivery_tag = delivery_tag,
                .multiple = multiple,
            };
        }
    },
    /// Confirm recovery.
    /// This method acknowledges a Basic.Recover method.
    basic_recover_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Reject one or more incoming messages.
    /// This method allows a client to reject one or more incoming messages. It can be
    /// used to interrupt and cancel large incoming messages, or return untreatable
    /// messages to their original queue.
    /// This method is also used by the server to inform publishers on channels in
    /// confirm mode of unhandled messages.  If a publisher receives this method, it
    /// probably needs to republish the offending messages.
    basic_nack: struct {
        delivery_tag: u64,
        /// Reject multiple messages.
        /// If set to 1, the delivery tag is treated as "up to and
        /// including", so that multiple messages can be rejected
        /// with a single method. If set to zero, the delivery tag
        /// refers to a single message. If the multiple field is 1, and
        /// the delivery tag is zero, this indicates rejection of
        /// all outstanding messages.
        multiple: bool,
        /// Requeue the message.
        /// If requeue is true, the server will attempt to requeue the message.  If requeue
        /// is false or the requeue  attempt fails the messages are discarded or dead-lettered.
        /// Clients receiving the Nack methods should ignore this flag.
        requeue: bool,

        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            const delivery_tag = try decoder.read_int(u64);
            const bitset_1: stdx.BitSetType(8) = .{ .bits = try decoder.read_int(u8) };
            const multiple = bitset_1.is_set(0);
            const requeue = bitset_1.is_set(1);

            return .{
                .delivery_tag = delivery_tag,
                .multiple = multiple,
                .requeue = requeue,
            };
        }
    },
    /// Confirm transaction mode.
    /// This method confirms to the client that the channel was successfully set to use
    /// standard transactions.
    tx_select_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm a successful commit.
    /// This method confirms to the client that the commit succeeded. Note that if a commit
    /// fails, the server raises a channel exception.
    tx_commit_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// Confirm successful rollback.
    /// This method confirms to the client that the rollback succeeded. Note that if an
    /// rollback fails, the server raises a channel exception.
    tx_rollback_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },
    /// This method confirms to the client that the channel was successfully
    /// set to use publisher acknowledgements.
    confirm_select_ok: struct {
        fn decode(decoder: *Decoder) Decoder.Error!@This() {
            _ = decoder;
            return .{};
        }
    },

    pub fn method_header(self: ClientMethod) MethodHeader {
        return @bitCast(@as(u32, @intFromEnum(self)));
    }

    pub fn decode(header: MethodHeader, decoder: *Decoder) Decoder.Error!ClientMethod {
        @setEvalBranchQuota(10_000);
        const tag: Tag = @enumFromInt(@as(u32, @bitCast(header)));
        const value: ClientMethod = switch (tag) {
            inline else => |tag_comptime| value: {
                const Method = std.meta.TagPayload(ClientMethod, tag_comptime);
                break :value @unionInit(
                    ClientMethod,
                    @tagName(tag_comptime),
                    try Method.decode(decoder),
                );
            },
        };
        try decoder.read_frame_end();
        return value;
    }
};

/// Methods sent by the client, marked by the spec
/// with `<chassis name="server" implement="MUST|MAY"/>`.
pub const ServerMethod = union(ServerMethod.Tag) {
    pub const Tag = enum(u32) {
        connection_start_ok = @bitCast(MethodHeader{ .class = 10, .method = 11 }),
        connection_secure_ok = @bitCast(MethodHeader{ .class = 10, .method = 21 }),
        connection_tune_ok = @bitCast(MethodHeader{ .class = 10, .method = 31 }),
        connection_open = @bitCast(MethodHeader{ .class = 10, .method = 40 }),
        connection_close = @bitCast(MethodHeader{ .class = 10, .method = 50 }),
        connection_close_ok = @bitCast(MethodHeader{ .class = 10, .method = 51 }),
        connection_blocked = @bitCast(MethodHeader{ .class = 10, .method = 60 }),
        connection_unblocked = @bitCast(MethodHeader{ .class = 10, .method = 61 }),
        connection_update_secret_ok = @bitCast(MethodHeader{ .class = 10, .method = 71 }),
        channel_open = @bitCast(MethodHeader{ .class = 20, .method = 10 }),
        channel_flow = @bitCast(MethodHeader{ .class = 20, .method = 20 }),
        channel_flow_ok = @bitCast(MethodHeader{ .class = 20, .method = 21 }),
        channel_close = @bitCast(MethodHeader{ .class = 20, .method = 40 }),
        channel_close_ok = @bitCast(MethodHeader{ .class = 20, .method = 41 }),
        exchange_declare = @bitCast(MethodHeader{ .class = 40, .method = 10 }),
        exchange_delete = @bitCast(MethodHeader{ .class = 40, .method = 20 }),
        exchange_bind = @bitCast(MethodHeader{ .class = 40, .method = 30 }),
        exchange_unbind = @bitCast(MethodHeader{ .class = 40, .method = 40 }),
        queue_declare = @bitCast(MethodHeader{ .class = 50, .method = 10 }),
        queue_bind = @bitCast(MethodHeader{ .class = 50, .method = 20 }),
        queue_unbind = @bitCast(MethodHeader{ .class = 50, .method = 50 }),
        queue_purge = @bitCast(MethodHeader{ .class = 50, .method = 30 }),
        queue_delete = @bitCast(MethodHeader{ .class = 50, .method = 40 }),
        basic_qos = @bitCast(MethodHeader{ .class = 60, .method = 10 }),
        basic_consume = @bitCast(MethodHeader{ .class = 60, .method = 20 }),
        basic_cancel = @bitCast(MethodHeader{ .class = 60, .method = 30 }),
        basic_cancel_ok = @bitCast(MethodHeader{ .class = 60, .method = 31 }),
        basic_publish = @bitCast(MethodHeader{ .class = 60, .method = 40 }),
        basic_get = @bitCast(MethodHeader{ .class = 60, .method = 70 }),
        basic_ack = @bitCast(MethodHeader{ .class = 60, .method = 80 }),
        basic_reject = @bitCast(MethodHeader{ .class = 60, .method = 90 }),
        basic_recover_async = @bitCast(MethodHeader{ .class = 60, .method = 100 }),
        basic_recover = @bitCast(MethodHeader{ .class = 60, .method = 110 }),
        basic_nack = @bitCast(MethodHeader{ .class = 60, .method = 120 }),
        tx_select = @bitCast(MethodHeader{ .class = 90, .method = 10 }),
        tx_commit = @bitCast(MethodHeader{ .class = 90, .method = 20 }),
        tx_rollback = @bitCast(MethodHeader{ .class = 90, .method = 30 }),
        confirm_select = @bitCast(MethodHeader{ .class = 85, .method = 10 }),
    };

    /// Select security mechanism and locale.
    /// This method selects a SASL security mechanism.
    connection_start_ok: struct {
        /// Client properties.
        client_properties: ?Encoder.Table,
        /// Selected security mechanism.
        /// A single security mechanisms selected by the client, which must be one of those
        /// specified by the server.
        mechanism: []const u8,
        /// Security response data.
        /// A block of opaque data passed to the security mechanism. The contents of this
        /// data are defined by the SASL security mechanism.
        response: ?Encoder.Body,
        /// Selected message locale.
        /// A single message locale selected by the client, which must be one of those
        /// specified by the server.
        locale: []const u8,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_table(self.client_properties);
            encoder.write_short_string(self.mechanism);
            encoder.write_long_string_body(self.response);
            encoder.write_short_string(self.locale);
        }
    },
    /// Security mechanism response.
    /// This method attempts to authenticate, passing a block of SASL data for the security
    /// mechanism at the server side.
    connection_secure_ok: struct {
        /// Security response data.
        /// A block of opaque data passed to the security mechanism. The contents of this
        /// data are defined by the SASL security mechanism.
        response: ?Encoder.Body,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_long_string_body(self.response);
        }
    },
    /// Negotiate connection tuning parameters.
    /// This method sends the client's connection tuning parameters to the server.
    /// Certain fields are negotiated, others provide capability information.
    connection_tune_ok: struct {
        /// Negotiated maximum channels.
        /// The maximum total number of channels that the client will use per connection.
        channel_max: u16,
        /// Negotiated maximum frame size.
        /// The largest frame size that the client and server will use for the connection.
        /// Zero means that the client does not impose any specific limit but may reject
        /// very large frames if it cannot allocate resources for them. Note that the
        /// frame-max limit applies principally to content frames, where large contents can
        /// be broken into frames of arbitrary size.
        frame_max: u32,
        /// Desired heartbeat delay.
        /// The delay, in seconds, of the connection heartbeat that the client wants. Zero
        /// means the client does not want a heartbeat.
        heartbeat: u16,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.channel_max);
            encoder.write_int(u32, self.frame_max);
            encoder.write_int(u16, self.heartbeat);
        }
    },
    /// Open connection to virtual host.
    /// This method opens a connection to a virtual host, which is a collection of
    /// resources, and acts to separate multiple application domains within a server.
    /// The server may apply arbitrary limits per virtual host, such as the number
    /// of each type of entity that may be used, per connection and/or in total.
    connection_open: struct {
        /// Virtual host name.
        /// The name of the virtual host to work with.
        virtual_host: []const u8,
        reserved_1: []const u8 = "",
        reserved_2: bool = false,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_short_string(self.virtual_host);
            encoder.write_short_string(self.reserved_1);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.reserved_2);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Request a connection close.
    /// This method indicates that the sender wants to close the connection. This may be
    /// due to internal conditions (e.g. a forced shut-down) or due to an error handling
    /// a specific method, i.e. an exception. When a close is due to an exception, the
    /// sender provides the class and method id of the method which caused the exception.
    connection_close: struct {
        reply_code: u16,
        reply_text: []const u8,
        /// Failing method class.
        /// When the close is provoked by a method exception, this is the class of the
        /// method.
        class_id: u16,
        /// Failing method id.
        /// When the close is provoked by a method exception, this is the ID of the method.
        method_id: u16,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reply_code);
            encoder.write_short_string(self.reply_text);
            encoder.write_int(u16, self.class_id);
            encoder.write_int(u16, self.method_id);
        }
    },
    /// Confirm a connection close.
    /// This method confirms a Connection.Close method and tells the recipient that it is
    /// safe to release resources for the connection and close the socket.
    connection_close_ok: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// Indicate that connection is blocked.
    /// This method indicates that a connection has been blocked
    /// and does not accept new publishes.
    connection_blocked: struct {
        /// Block reason.
        /// The reason the connection was blocked.
        reason: []const u8,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_short_string(self.reason);
        }
    },
    /// Indicate that connection is unblocked.
    /// This method indicates that a connection has been unblocked
    /// and now accepts publishes.
    connection_unblocked: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// Update secret response.
    /// This method confirms the updated secret is valid.
    connection_update_secret_ok: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// Open a channel for use.
    /// This method opens a channel to the server.
    channel_open: struct {
        reserved_1: []const u8 = "",

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_short_string(self.reserved_1);
        }
    },
    /// Enable/disable flow from peer.
    /// This method asks the peer to pause or restart the flow of content data sent by
    /// a consumer. This is a simple flow-control mechanism that a peer can use to avoid
    /// overflowing its queues or otherwise finding itself receiving more messages than
    /// it can process. Note that this method is not intended for window control. It does
    /// not affect contents returned by Basic.Get-Ok methods.
    channel_flow: struct {
        /// Start/stop content frames.
        /// If 1, the peer starts sending content frames. If 0, the peer stops sending
        /// content frames.
        active: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.active);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Confirm a flow method.
    /// Confirms to the peer that a flow command was received and processed.
    channel_flow_ok: struct {
        /// Current flow setting.
        /// Confirms the setting of the processed flow method: 1 means the peer will start
        /// sending or continue to send content frames; 0 means it will not.
        active: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.active);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Request a channel close.
    /// This method indicates that the sender wants to close the channel. This may be due to
    /// internal conditions (e.g. a forced shut-down) or due to an error handling a specific
    /// method, i.e. an exception. When a close is due to an exception, the sender provides
    /// the class and method id of the method which caused the exception.
    channel_close: struct {
        reply_code: u16,
        reply_text: []const u8,
        /// Failing method class.
        /// When the close is provoked by a method exception, this is the class of the
        /// method.
        class_id: u16,
        /// Failing method id.
        /// When the close is provoked by a method exception, this is the ID of the method.
        method_id: u16,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reply_code);
            encoder.write_short_string(self.reply_text);
            encoder.write_int(u16, self.class_id);
            encoder.write_int(u16, self.method_id);
        }
    },
    /// Confirm a channel close.
    /// This method confirms a Channel.Close method and tells the recipient that it is safe
    /// to release resources for the channel.
    channel_close_ok: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// Verify exchange exists, create if needed.
    /// This method creates an exchange if it does not already exist, and if the exchange
    /// exists, verifies that it is of the correct and expected class.
    exchange_declare: struct {
        reserved_1: u16 = 0,
        exchange: []const u8,
        /// Exchange type.
        /// Each exchange belongs to one of a set of exchange types implemented by the
        /// server. The exchange types define the functionality of the exchange - i.e. how
        /// messages are routed through it. It is not valid or meaningful to attempt to
        /// change the type of an existing exchange.
        type: []const u8,
        /// Do not create exchange.
        /// If set, the server will reply with Declare-Ok if the exchange already
        /// exists with the same name, and raise an error if not.  The client can
        /// use this to check whether an exchange exists without modifying the
        /// server state. When set, all other method fields except name and no-wait
        /// are ignored.  A declare with both passive and no-wait has no effect.
        /// Arguments are compared for semantic equivalence.
        passive: bool,
        /// Request a durable exchange.
        /// If set when creating a new exchange, the exchange will be marked as durable.
        /// Durable exchanges remain active when a server restarts. Non-durable exchanges
        /// (transient exchanges) are purged if/when a server restarts.
        durable: bool,
        /// Auto-delete when unused.
        /// If set, the exchange is deleted when all queues have
        /// finished using it.
        auto_delete: bool,
        /// Create internal exchange.
        /// If set, the exchange may not be used directly by publishers,
        /// but only when bound to other exchanges. Internal exchanges
        /// are used to construct wiring that is not visible to
        /// applications.
        internal: bool,
        no_wait: bool,
        /// Arguments for declaration.
        /// A set of arguments for the declaration. The syntax and semantics of these
        /// arguments depends on the server implementation.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.exchange);
            encoder.write_short_string(self.type);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.passive);
            bitset_1.set_value(1, self.durable);
            bitset_1.set_value(2, self.auto_delete);
            bitset_1.set_value(3, self.internal);
            bitset_1.set_value(4, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
            encoder.write_table(self.arguments);
        }
    },
    /// Delete an exchange.
    /// This method deletes an exchange. When an exchange is deleted all queue bindings on
    /// the exchange are cancelled.
    exchange_delete: struct {
        reserved_1: u16 = 0,
        exchange: []const u8,
        /// Delete only if unused.
        /// If set, the server will only delete the exchange if it has no queue bindings. If
        /// the exchange has queue bindings the server does not delete it but raises a
        /// channel exception instead.
        if_unused: bool,
        no_wait: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.exchange);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.if_unused);
            bitset_1.set_value(1, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Bind exchange to an exchange.
    /// This method binds an exchange to an exchange.
    exchange_bind: struct {
        reserved_1: u16 = 0,
        /// Name of the destination exchange to bind to.
        /// Specifies the name of the destination exchange to bind.
        destination: []const u8,
        /// Name of the source exchange to bind to.
        /// Specifies the name of the source exchange to bind.
        source: []const u8,
        /// Message routing key.
        /// Specifies the routing key for the binding. The routing key
        /// is used for routing messages depending on the exchange
        /// configuration. Not all exchanges use a routing key - refer
        /// to the specific exchange documentation.
        routing_key: []const u8,
        no_wait: bool,
        /// Arguments for binding.
        /// A set of arguments for the binding. The syntax and semantics
        /// of these arguments depends on the exchange class.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.destination);
            encoder.write_short_string(self.source);
            encoder.write_short_string(self.routing_key);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
            encoder.write_table(self.arguments);
        }
    },
    /// Unbind an exchange from an exchange.
    /// This method unbinds an exchange from an exchange.
    exchange_unbind: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the destination exchange to unbind.
        destination: []const u8,
        /// Specifies the name of the source exchange to unbind.
        source: []const u8,
        /// Routing key of binding.
        /// Specifies the routing key of the binding to unbind.
        routing_key: []const u8,
        no_wait: bool,
        /// Arguments of binding.
        /// Specifies the arguments of the binding to unbind.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.destination);
            encoder.write_short_string(self.source);
            encoder.write_short_string(self.routing_key);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
            encoder.write_table(self.arguments);
        }
    },
    /// Declare queue, create if needed.
    /// This method creates or checks a queue. When creating a new queue the client can
    /// specify various properties that control the durability of the queue and its
    /// contents, and the level of sharing for the queue.
    queue_declare: struct {
        reserved_1: u16 = 0,
        queue: []const u8,
        /// Do not create queue.
        /// If set, the server will reply with Declare-Ok if the queue already
        /// exists with the same name, and raise an error if not.  The client can
        /// use this to check whether a queue exists without modifying the
        /// server state.  When set, all other method fields except name and no-wait
        /// are ignored.  A declare with both passive and no-wait has no effect.
        /// Arguments are compared for semantic equivalence.
        passive: bool,
        /// Request a durable queue.
        /// If set when creating a new queue, the queue will be marked as durable. Durable
        /// queues remain active when a server restarts. Non-durable queues (transient
        /// queues) are purged if/when a server restarts. Note that durable queues do not
        /// necessarily hold persistent messages, although it does not make sense to send
        /// persistent messages to a transient queue.
        durable: bool,
        /// Request an exclusive queue.
        /// Exclusive queues may only be accessed by the current connection, and are
        /// deleted when that connection closes.  Passive declaration of an exclusive
        /// queue by other connections are not allowed.
        exclusive: bool,
        /// Auto-delete queue when unused.
        /// If set, the queue is deleted when all consumers have finished using it.  The last
        /// consumer can be cancelled either explicitly or because its channel is closed. If
        /// there was no consumer ever on the queue, it won't be deleted.  Applications can
        /// explicitly delete auto-delete queues using the Delete method as normal.
        auto_delete: bool,
        no_wait: bool,
        /// Arguments for declaration.
        /// A set of arguments for the declaration. The syntax and semantics of these
        /// arguments depends on the server implementation.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.passive);
            bitset_1.set_value(1, self.durable);
            bitset_1.set_value(2, self.exclusive);
            bitset_1.set_value(3, self.auto_delete);
            bitset_1.set_value(4, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
            encoder.write_table(self.arguments);
        }
    },
    /// Bind queue to an exchange.
    /// This method binds a queue to an exchange. Until a queue is bound it will not
    /// receive any messages. In a classic messaging model, store-and-forward queues
    /// are bound to a direct exchange and subscription queues are bound to a topic
    /// exchange.
    queue_bind: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the queue to bind.
        queue: []const u8,
        /// Name of the exchange to bind to.
        exchange: []const u8,
        /// Message routing key.
        /// Specifies the routing key for the binding. The routing key is used for routing
        /// messages depending on the exchange configuration. Not all exchanges use a
        /// routing key - refer to the specific exchange documentation.  If the queue name
        /// is empty, the server uses the last queue declared on the channel.  If the
        /// routing key is also empty, the server uses this queue name for the routing
        /// key as well.  If the queue name is provided but the routing key is empty, the
        /// server does the binding with that empty routing key.  The meaning of empty
        /// routing keys depends on the exchange implementation.
        routing_key: []const u8,
        no_wait: bool,
        /// Arguments for binding.
        /// A set of arguments for the binding. The syntax and semantics of these arguments
        /// depends on the exchange class.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            encoder.write_short_string(self.exchange);
            encoder.write_short_string(self.routing_key);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
            encoder.write_table(self.arguments);
        }
    },
    /// Unbind a queue from an exchange.
    /// This method unbinds a queue from an exchange.
    queue_unbind: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the queue to unbind.
        queue: []const u8,
        /// The name of the exchange to unbind from.
        exchange: []const u8,
        /// Routing key of binding.
        /// Specifies the routing key of the binding to unbind.
        routing_key: []const u8,
        /// Arguments of binding.
        /// Specifies the arguments of the binding to unbind.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            encoder.write_short_string(self.exchange);
            encoder.write_short_string(self.routing_key);
            encoder.write_table(self.arguments);
        }
    },
    /// Purge a queue.
    /// This method removes all messages from a queue which are not awaiting
    /// acknowledgment.
    queue_purge: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the queue to purge.
        queue: []const u8,
        no_wait: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Delete a queue.
    /// This method deletes a queue. When a queue is deleted any pending messages are sent
    /// to a dead-letter queue if this is defined in the server configuration, and all
    /// consumers on the queue are cancelled.
    queue_delete: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the queue to delete.
        queue: []const u8,
        /// Delete only if unused.
        /// If set, the server will only delete the queue if it has no consumers. If the
        /// queue has consumers the server does does not delete it but raises a channel
        /// exception instead.
        if_unused: bool,
        /// Delete only if empty.
        /// If set, the server will only delete the queue if it has no messages.
        if_empty: bool,
        no_wait: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.if_unused);
            bitset_1.set_value(1, self.if_empty);
            bitset_1.set_value(2, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Specify quality of service.
    /// This method requests a specific quality of service. The QoS can be specified for the
    /// current channel or for all channels on the connection. The particular properties and
    /// semantics of a qos method always depend on the content class semantics. Though the
    /// qos method could in principle apply to both peers, it is currently meaningful only
    /// for the server.
    basic_qos: struct {
        /// Prefetch window in octets.
        /// The client can request that messages be sent in advance so that when the client
        /// finishes processing a message, the following message is already held locally,
        /// rather than needing to be sent down the channel. Prefetching gives a performance
        /// improvement. This field specifies the prefetch window size in octets. The server
        /// will send a message in advance if it is equal to or smaller in size than the
        /// available prefetch size (and also falls into other prefetch limits). May be set
        /// to zero, meaning "no specific limit", although other prefetch limits may still
        /// apply. The prefetch-size is ignored if the no-ack option is set.
        prefetch_size: u32,
        /// Prefetch window in messages.
        /// Specifies a prefetch window in terms of whole messages. This field may be used
        /// in combination with the prefetch-size field; a message will only be sent in
        /// advance if both prefetch windows (and those at the channel and connection level)
        /// allow it. The prefetch-count is ignored if the no-ack option is set.
        prefetch_count: u16,
        /// Apply to entire connection.
        /// RabbitMQ has reinterpreted this field. The original
        /// specification said: "By default the QoS settings apply to
        /// the current channel only. If this field is set, they are
        /// applied to the entire connection." Instead, RabbitMQ takes
        /// global=false to mean that the QoS settings should apply
        /// per-consumer (for new consumers on the channel; existing
        /// ones being unaffected) and global=true to mean that the QoS
        /// settings should apply per-channel.
        global: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u32, self.prefetch_size);
            encoder.write_int(u16, self.prefetch_count);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.global);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Start a queue consumer.
    /// This method asks the server to start a "consumer", which is a transient request for
    /// messages from a specific queue. Consumers last as long as the channel they were
    /// declared on, or until the client cancels them.
    basic_consume: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the queue to consume from.
        queue: []const u8,
        /// Specifies the identifier for the consumer. The consumer tag is local to a
        /// channel, so two clients can use the same consumer tags. If this field is
        /// empty the server will generate a unique tag.
        consumer_tag: []const u8,
        no_local: bool,
        no_ack: bool,
        /// Request exclusive access.
        /// Request exclusive consumer access, meaning only this consumer can access the
        /// queue.
        exclusive: bool,
        no_wait: bool,
        /// Arguments for declaration.
        /// A set of arguments for the consume. The syntax and semantics of these
        /// arguments depends on the server implementation.
        arguments: ?Encoder.Table,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            encoder.write_short_string(self.consumer_tag);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_local);
            bitset_1.set_value(1, self.no_ack);
            bitset_1.set_value(2, self.exclusive);
            bitset_1.set_value(3, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
            encoder.write_table(self.arguments);
        }
    },
    /// End a queue consumer.
    /// This method cancels a consumer. This does not affect already delivered
    /// messages, but it does mean the server will not send any more messages for
    /// that consumer. The client may receive an arbitrary number of messages in
    /// between sending the cancel method and receiving the cancel-ok reply.
    /// It may also be sent from the server to the client in the event
    /// of the consumer being unexpectedly cancelled (i.e. cancelled
    /// for any reason other than the server receiving the
    /// corresponding basic.cancel from the client). This allows
    /// clients to be notified of the loss of consumers due to events
    /// such as queue deletion. Note that as it is not a MUST for
    /// clients to accept this method from the server, it is advisable
    /// for the broker to be able to identify those clients that are
    /// capable of accepting the method, through some means of
    /// capability negotiation.
    basic_cancel: struct {
        consumer_tag: []const u8,
        no_wait: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_short_string(self.consumer_tag);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_wait);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Confirm a cancelled consumer.
    /// This method confirms that the cancellation was completed.
    basic_cancel_ok: struct {
        consumer_tag: []const u8,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_short_string(self.consumer_tag);
        }
    },
    /// Publish a message.
    /// This method publishes a message to a specific exchange. The message will be routed
    /// to queues as defined by the exchange configuration and distributed to any active
    /// consumers when the transaction, if any, is committed.
    basic_publish: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the exchange to publish to. The exchange name can be
        /// empty, meaning the default exchange. If the exchange name is specified, and that
        /// exchange does not exist, the server will raise a channel exception.
        exchange: []const u8,
        /// Message routing key.
        /// Specifies the routing key for the message. The routing key is used for routing
        /// messages depending on the exchange configuration.
        routing_key: []const u8,
        /// Indicate mandatory routing.
        /// This flag tells the server how to react if the message cannot be routed to a
        /// queue. If this flag is set, the server will return an unroutable message with a
        /// Return method. If this flag is zero, the server silently drops the message.
        mandatory: bool,
        /// Request immediate delivery.
        /// This flag tells the server how to react if the message cannot be routed to a
        /// queue consumer immediately. If this flag is set, the server will return an
        /// undeliverable message with a Return method. If this flag is zero, the server
        /// will queue the message, but with no guarantee that it will ever be consumed.
        immediate: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.exchange);
            encoder.write_short_string(self.routing_key);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.mandatory);
            bitset_1.set_value(1, self.immediate);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Direct access to a queue.
    /// This method provides a direct access to the messages in a queue using a synchronous
    /// dialogue that is designed for specific types of application where synchronous
    /// functionality is more important than performance.
    basic_get: struct {
        reserved_1: u16 = 0,
        /// Specifies the name of the queue to get a message from.
        queue: []const u8,
        no_ack: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u16, self.reserved_1);
            encoder.write_short_string(self.queue);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.no_ack);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Acknowledge one or more messages.
    /// When sent by the client, this method acknowledges one or more
    /// messages delivered via the Deliver or Get-Ok methods.
    /// When sent by server, this method acknowledges one or more
    /// messages published with the Publish method on a channel in
    /// confirm mode.
    /// The acknowledgement can be for a single message or a set of
    /// messages up to and including a specific message.
    basic_ack: struct {
        delivery_tag: u64,
        /// Acknowledge multiple messages.
        /// If set to 1, the delivery tag is treated as "up to and
        /// including", so that multiple messages can be acknowledged
        /// with a single method. If set to zero, the delivery tag
        /// refers to a single message. If the multiple field is 1, and
        /// the delivery tag is zero, this indicates acknowledgement of
        /// all outstanding messages.
        multiple: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u64, self.delivery_tag);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.multiple);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Reject an incoming message.
    /// This method allows a client to reject a message. It can be used to interrupt and
    /// cancel large incoming messages, or return untreatable messages to their original
    /// queue.
    basic_reject: struct {
        delivery_tag: u64,
        /// Requeue the message.
        /// If requeue is true, the server will attempt to requeue the message.  If requeue
        /// is false or the requeue  attempt fails the messages are discarded or dead-lettered.
        requeue: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u64, self.delivery_tag);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.requeue);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Redeliver unacknowledged messages.
    /// This method asks the server to redeliver all unacknowledged messages on a
    /// specified channel. Zero or more messages may be redelivered.  This method
    /// is deprecated in favour of the synchronous Recover/Recover-Ok.
    basic_recover_async: struct {
        /// Requeue the message.
        /// If this field is zero, the message will be redelivered to the original
        /// recipient. If this bit is 1, the server will attempt to requeue the message,
        /// potentially then delivering it to an alternative subscriber.
        requeue: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.requeue);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Redeliver unacknowledged messages.
    /// This method asks the server to redeliver all unacknowledged messages on a
    /// specified channel. Zero or more messages may be redelivered.  This method
    /// replaces the asynchronous Recover.
    basic_recover: struct {
        /// Requeue the message.
        /// If this field is zero, the message will be redelivered to the original
        /// recipient. If this bit is 1, the server will attempt to requeue the message,
        /// potentially then delivering it to an alternative subscriber.
        requeue: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.requeue);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Reject one or more incoming messages.
    /// This method allows a client to reject one or more incoming messages. It can be
    /// used to interrupt and cancel large incoming messages, or return untreatable
    /// messages to their original queue.
    /// This method is also used by the server to inform publishers on channels in
    /// confirm mode of unhandled messages.  If a publisher receives this method, it
    /// probably needs to republish the offending messages.
    basic_nack: struct {
        delivery_tag: u64,
        /// Reject multiple messages.
        /// If set to 1, the delivery tag is treated as "up to and
        /// including", so that multiple messages can be rejected
        /// with a single method. If set to zero, the delivery tag
        /// refers to a single message. If the multiple field is 1, and
        /// the delivery tag is zero, this indicates rejection of
        /// all outstanding messages.
        multiple: bool,
        /// Requeue the message.
        /// If requeue is true, the server will attempt to requeue the message.  If requeue
        /// is false or the requeue  attempt fails the messages are discarded or dead-lettered.
        /// Clients receiving the Nack methods should ignore this flag.
        requeue: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            encoder.write_int(u64, self.delivery_tag);
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.multiple);
            bitset_1.set_value(1, self.requeue);
            encoder.write_int(u8, bitset_1.bits);
        }
    },
    /// Select standard transaction mode.
    /// This method sets the channel to use standard transactions. The client must use this
    /// method at least once on a channel before using the Commit or Rollback methods.
    tx_select: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// Commit the current transaction.
    /// This method commits all message publications and acknowledgments performed in
    /// the current transaction.  A new transaction starts immediately after a commit.
    tx_commit: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// Abandon the current transaction.
    /// This method abandons all message publications and acknowledgments performed in
    /// the current transaction. A new transaction starts immediately after a rollback.
    /// Note that unacked messages will not be automatically redelivered by rollback;
    /// if that is required an explicit recover call should be issued.
    tx_rollback: struct {
        fn encode(self: *const @This(), encoder: *Encoder) void {
            _ = self;
            _ = encoder;
        }
    },
    /// This method sets the channel to use publisher acknowledgements.
    /// The client can only use this method on a non-transactional
    /// channel.
    confirm_select: struct {
        nowait: bool,

        fn encode(self: *const @This(), encoder: *Encoder) void {
            var bitset_1: stdx.BitSetType(8) = .{};
            bitset_1.set_value(0, self.nowait);
            encoder.write_int(u8, bitset_1.bits);
        }
    },

    pub fn method_header(self: ServerMethod) MethodHeader {
        return @bitCast(@as(u32, @intFromEnum(self)));
    }

    pub fn encode(self: ServerMethod, channel: u16, encoder: *Encoder) void {
        const frame_reference = encoder.begin_frame(.{
            .type = .method,
            .channel = channel,
        });
        switch (self) {
            inline else => |method| {
                encoder.write_method_header(self.method_header());
                method.encode(encoder);
            },
        }
        encoder.finish_frame(frame_reference);
    }
};
