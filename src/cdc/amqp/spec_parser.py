## Converts the Advanced Message Queuing Protocol (AMQP) specification into Zig declarations.
## Usage: `python spec_parser.py amqp0-9-1.xml > spec.zig`
##
## Please refer to https://www.amqp.org/sites/amqp.org/files/amqp0-9-1.zip to download the
## official specification XML and additional documentation.
##
## Alternatively, refer to the RabbitMQ extended AMQP 0.9.1 specification:
## https://github.com/rabbitmq/amqp-0.9.1-spec/blob/main/xml/amqp0-9-1.extended.xml

import xml.etree.ElementTree as Tree
import sys


read_types = {
        'shortstr': "[]const u8",
        'longstr': "[]const u8",
        'bit': "bool",
        'octet': "u8",
        'short': "u16",
        'long': "u32",
        'longlong': "u64",
        'timestamp': "u64",
        'table': "Decoder.Table",
    }

reader = {
        'octet': "read_int(u8)",
        'short': "read_int(u16)",
        'long': "read_int(u32)",
        'longlong': "read_int(u64)",
        'bit': "read_int(u8)",
        'shortstr': 'read_short_string()',
        'longstr': 'read_long_string()',
        'table': "read_table()",
        'timestamp': 'read_int(u64)',
    }

write_types = {
        'shortstr': "[]const u8",
        'longstr': "?Encoder.Body",
        'bit': "bool",
        'octet': "u8",
        'short': "u16",
        'long': "u32",
        'longlong': "u64",
        'timestamp': "u64",
        'table': "?Encoder.Table",
    }

writer = {
        'octet': "write_int(u8, ",
        'short': "write_int(u16, ",
        'long': "write_int(u32, ",
        'longlong': "write_int(u64, ",
        'bit': "write_int(u8, ",
        'shortstr': 'write_short_string(',
        'longstr': 'write_long_string_body(',
        'table': "write_table(",
        'timestamp': 'write_int(u64, ',
    }

write_defaults = {
        '[]const u8': "\"\"",
        'bool': "false",
        'u8': "0",
        'u16': "0",
        'u32': "0",
        'u64': "0",
    }

class Source:
    client = 1
    server = 2

def main(file):
    xml = Tree.parse(file)
    root = xml.getroot()
    if root.tag == 'amqp':
        for element in root.findall('domain'):
            domain = element.get('name')
            type = element.get('type')
            read_types[domain] = read_types[type]
            reader[domain] = reader[type]
            write_types[domain] = write_types[type]
            writer[domain] = writer[type]

        print(f"//////////////////////////////////////////////////////////")
        print(f"// This file was auto-generated by spec_parser.py       //")
        print(f"//              Do not manually modify.                 //")
        print(f"//////////////////////////////////////////////////////////")
        print(f"")
        print(f"const std = @import(\"std\");")
        print(f"const stdx = @import(\"../../stdx.zig\");")
        print(f"const protocol = @import(\"protocol.zig\");")
        print(f"const Decoder = protocol.Decoder;")
        print(f"const Encoder = protocol.Encoder;")
        print(f"const MethodHeader = protocol.MethodHeader;")
        print(f"")
        constants(root)
        client_methods(root)
        server_methods(root)

def constants(root):
    constants = root.findall('constant')
    for element in constants:
        docs(element)
        name = element.get('name')
        class_attribute = element.get('class')
        name = f"{class_attribute}_{name}" if class_attribute else name
        print(f"pub const {to_upper_case(name)} = {element.get('value')};")

def client_methods(root):
    print(f"")
    print(f"/// Methods sent by the AMQP server that must be handled by the client side,")
    print(f"/// marked by the spec with `<chassis name=\"client\" implement=\"MUST|MAY\"/>`.")
    print(f"pub const ClientMethod = union(ClientMethod.Tag) {{")
    print(f"    pub const Tag = enum(u32) {{")
    classes = root.findall('class')
    for class_ in classes:
        class_index = class_.get('index')
        methods = class_.findall('method')
        for method in methods:
            if method.find("chassis[@name='client']") is None: continue
            method_index = method.get('index')
            enum_name = to_lower_case(class_.get('name') + '_' + method.get('name'))
            print(f"        {enum_name} = @bitCast(MethodHeader{{ .class = {class_index}, .method = {method_index} }}),")
    print(f"    }};")
    print(f"")
    for class_ in classes:
        methods = class_.findall('method')
        for method in methods:
            if method.find("chassis[@name='client']") is None: continue
            enum_name = to_lower_case(class_.get('name') + '_' + method.get('name'))
            indent = "    "
            docs(method, indent)
            print(f"{indent}{enum_name}: struct {{")
            class_method(Source.client, method, indent)
            print(f"{indent}}},")
    print(f"")
    print(f"    pub fn method_header(self: ClientMethod) MethodHeader {{")
    print(f"        return @bitCast(@as(u32, @intFromEnum(self)));")
    print(f"    }}")
    print(f"")
    print(f"    pub fn decode(header: MethodHeader, decoder: *Decoder) Decoder.Error!ClientMethod {{")
    print(f"        @setEvalBranchQuota(10_000);")
    print(f"        const tag: Tag = @enumFromInt(@as(u32, @bitCast(header)));")
    print(f"        const value: ClientMethod = switch (tag) {{")
    print(f"            inline else => |tag_comptime| value: {{")
    print(f"                const Method = std.meta.TagPayload(ClientMethod, tag_comptime);")
    print(f"                break :value @unionInit(")
    print(f"                    ClientMethod,")
    print(f"                    @tagName(tag_comptime),")
    print(f"                    try Method.decode(decoder),")
    print(f"                );")
    print(f"            }},")
    print(f"        }};")
    print(f"        try decoder.read_frame_end();")
    print(f"        return value;")
    print(f"    }}")
    print(f"}};")

def server_methods(root):
    print(f"")
    print(f"/// Methods sent by the client, marked by the spec")
    print(f"/// with `<chassis name=\"server\" implement=\"MUST|MAY\"/>`.")
    print(f"pub const ServerMethod = union(ServerMethod.Tag) {{")
    print(f"    pub const Tag = enum(u32) {{")
    classes = root.findall('class')
    for class_ in classes:
        methods = class_.findall('method')
        for method in methods:
            if method.find("chassis[@name='server']") is None: continue
            class_index = class_.get('index')
            method_index = method.get('index')
            enum_name = to_lower_case(class_.get('name') + '_' + method.get('name'))
            print(f"        {enum_name} = @bitCast(MethodHeader{{ .class = {class_index}, .method = {method_index} }}),")
    print(f"    }};")
    print(f"")
    for class_ in classes:
        methods = class_.findall('method')
        for method in methods:
            if method.find("chassis[@name='server']") is None: continue
            enum_name = to_lower_case(class_.get('name') + '_' + method.get('name'))
            indent = "    "
            docs(method, indent)
            print(f"{indent}{enum_name}: struct {{")
            class_method(Source.server, method, indent)
            print(f"{indent}}},")
    print(f"")
    print(f"    pub fn method_header(self: ServerMethod) MethodHeader {{")
    print(f"        return @bitCast(@as(u32, @intFromEnum(self)));")
    print(f"    }}")
    print(f"")
    print(f"    pub fn encode(self: ServerMethod, channel: u16, encoder: *Encoder) void {{")
    print(f"        const frame_reference = encoder.begin_frame(.{{")
    print(f"            .type = .method,")
    print(f"            .channel = channel,")
    print(f"        }});")
    print(f"        switch (self) {{")
    print(f"            inline else => |method| {{")
    print(f"                encoder.write_method_header(self.method_header());")
    print(f"                method.encode(encoder);")
    print(f"            }},")
    print(f"        }}")
    print(f"        encoder.finish_frame(frame_reference);")
    print(f"    }}")
    print(f"}};")

def class_method(source, method, indent=""):
    method_fields(source, method, indent)
    if source == Source.client: decode(method, indent)
    if source == Source.server: encode(method, indent)

def method_fields(source, method, indent=""):
    indent += "    "
    fields = method.findall('field')
    if fields:
        for element in fields:
            field = to_lower_case(element.get('name'))
            types = read_types if source == Source.client else write_types
            type = types[element.get('domain', element.get('type'))]
            has_default = source == Source.server and field.startswith('reserved')
            default = f" = {write_defaults[type]}" if has_default else ""
            docs(element, indent)
            print(f"{indent}{field}: {type}{default},")
        print(f"")

def decode(method, indent=""):
    if method.find("chassis[@name='client']") is None: return
    indent += "    "
    print(f"{indent}fn decode(decoder: *Decoder) Decoder.Error!@This() {{")
    fields = method.findall('field')
    if fields:
        bitset_octets = 0
        bitset_index = 0
        for element in fields:
            field = to_lower_case(element.get('name'))
            type = read_types[element.get('domain', element.get('type'))]
            read_function = reader[element.get('domain', element.get('type'))]
            if type == 'bool':
                if bitset_index == 0:
                    bitset_octets += 1
                    print(f"{indent}    const bitset_{bitset_octets}: stdx.BitSetType(8) = .{{ .bits = try decoder.{read_function} }};")
                print(f"{indent}    const {field} = bitset_{bitset_octets}.is_set({bitset_index});")
                bitset_index += 1
            else:
                print(f"{indent}    const {field} = try decoder.{read_function};")
                bitset_index = 0
        print(f"");
        print(f"{indent}    return .{{")
        for element in fields:
            field = to_lower_case(element.get('name'))
            print(f"{indent}        .{field} = {field},")
        print(f"{indent}    }};")
    else:
        print(f"{indent}    _ = decoder;")
        print(f"{indent}    return .{{}};")
    print(f"{indent}}}")

def encode(method, indent = ""):
    if method.find("chassis[@name='server']") is None: return
    indent += "    "
    print(f"{indent}fn encode(self: *const @This(), encoder: *Encoder) void {{")
    fields = method.findall('field')
    if fields:
        bitset_octets = 0
        bitset_index = 0
        for element in fields:
            field = to_lower_case(element.get('name'))
            type = write_types[element.get('domain', element.get('type'))]
            write_function = writer[element.get('domain', element.get('type'))]
            if type == 'bool':
                if bitset_index == 0:
                    bitset_octets += 1
                    print(f"{indent}    var bitset_{bitset_octets}: stdx.BitSetType(8) = .{{}};")
                print(f"{indent}    bitset_{bitset_octets}.set_value({bitset_index}, self.{field});")
                bitset_index += 1
            else:
                if bitset_index > 0:
                    print(f"{indent}    encoder.{writer['bit']}bitset_{bitset_octets}.bits);")
                print(f"{indent}    encoder.{write_function}self.{field});")
                bitset_index = 0
        if bitset_index > 0:
            print(f"{indent}    encoder.{writer['bit']}bitset_{bitset_octets}.bits);")
    else:
        print(f"{indent}    _ = self;")
        print(f"{indent}    _ = encoder;")
    print(f"{indent}}}")

def docs(element, indent=""):
    label = element.get('label')
    if label: print(f"{indent}/// {label.capitalize()}.")
    for doc in element.findall('doc'):
        if (doc.get('type') == 'grammar'): continue
        lines = doc.text.split("\n")
        for line in lines:
            line = line.strip()
            if line:
                print(f"{indent}/// {line}")

def to_upper_case(name):
    name = name.replace('-', '_').upper()
    return name

def to_lower_case(name):
    name = name.replace('-', '_').lower()
    return name

def to_pascal_case(name):
    name = ''.join([x.capitalize() for x in name.split('-')])
    return name

main(sys.argv[1])