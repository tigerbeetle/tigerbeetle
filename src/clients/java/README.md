<!-- This file is generated by [/src/scripts/client_readmes.zig](/src/scripts/client_readmes.zig). -->
# tigerbeetle-java

The TigerBeetle client for Java.

[![javadoc](https://javadoc.io/badge2/com.tigerbeetle/tigerbeetle-java/javadoc.svg)](https://javadoc.io/doc/com.tigerbeetle/tigerbeetle-java)

[![maven-central](https://img.shields.io/maven-central/v/com.tigerbeetle/tigerbeetle-java)](https://central.sonatype.com/namespace/com.tigerbeetle)

## Prerequisites

Linux >= 5.6 is the only production environment we
support. But for ease of development we also support macOS and Windows.
* Java >= 11
* Maven >= 3.6 (not strictly necessary but it's what our guides assume)

## Setup

First, create a directory for your project and `cd` into the directory.

Then create `pom.xml` and copy this into it:

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.tigerbeetle</groupId>
  <artifactId>samples</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <maven.compiler.source>11</maven.compiler.source>
    <maven.compiler.target>11</maven.compiler.target>
  </properties>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <version>3.8.1</version>
        <configuration>
          <compilerArgs>
            <arg>-Xlint:all,-options,-path</arg>
          </compilerArgs>
        </configuration>
      </plugin>

      <plugin>
        <groupId>org.codehaus.mojo</groupId>
        <artifactId>exec-maven-plugin</artifactId>
        <version>1.6.0</version>
        <configuration>
          <mainClass>com.tigerbeetle.samples.Main</mainClass>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>com.tigerbeetle</groupId>
      <artifactId>tigerbeetle-java</artifactId>
      <!-- Grab the latest commit from: https://repo1.maven.org/maven2/com/tigerbeetle/tigerbeetle-java/maven-metadata.xml -->
      <version>0.0.1-3431</version>
    </dependency>
  </dependencies>
</project>
```

Then, install the TigerBeetle client:

```console
mvn install
```

Now, create `src/main/java/Main.java` and copy this into it:

```java
import com.tigerbeetle.*;

public final class Main {
    public static void main(String[] args) throws Exception {
        System.out.println("Import ok!");
    }
}
```

Finally, build and run:

```console
mvn exec:java
```

Now that all prerequisites and dependencies are correctly set
up, let's dig into using TigerBeetle.

## Sample projects

This document is primarily a reference guide to
the client. Below are various sample projects demonstrating
features of TigerBeetle.

* [Basic](/src/clients/java/samples/basic/): Create two accounts and transfer an amount between them.
* [Two-Phase Transfer](/src/clients/java/samples/two-phase/): Create two accounts and start a pending transfer between
them, then post the transfer.
* [Many Two-Phase Transfers](/src/clients/java/samples/two-phase-many/): Create two accounts and start a number of pending transfer
between them, posting and voiding alternating transfers.
## Creating a Client

A client is created with a cluster ID and replica
addresses for all replicas in the cluster. The cluster
ID and replica addresses are both chosen by the system that
starts the TigerBeetle cluster.

Clients are thread-safe and a single instance should be shared
between multiple concurrent tasks.

Multiple clients are useful when connecting to more than
one TigerBeetle cluster.

In this example the cluster ID is `0` and there is one
replica. The address is read from the `TB_ADDRESS`
environment variable and defaults to port `3000`.

```java
String replicaAddress = System.getenv("TB_ADDRESS");
byte[] clusterID = UInt128.asBytes(0);
String[] replicaAddresses = new String[] {replicaAddress == null ? "3000" : replicaAddress};
try (var client = new Client(clusterID, replicaAddresses)) {
    // Use client
}
```

The following are valid addresses:
* `3000` (interpreted as `127.0.0.1:3000`)
* `127.0.0.1:3000` (interpreted as `127.0.0.1:3000`)
* `127.0.0.1` (interpreted as `127.0.0.1:3001`, `3001` is the default port)

## Creating Accounts

See details for account fields in the [Accounts
reference](https://docs.tigerbeetle.com/reference/account).

```java
AccountBatch accounts = new AccountBatch(1);
accounts.add();
accounts.setId(UInt128.id()); // TigerBeetle time-based ID.
accounts.setUserData128(0, 0);
accounts.setUserData64(0);
accounts.setUserData32(0);
accounts.setLedger(1);
accounts.setCode(718);
accounts.setFlags(AccountFlags.NONE);
accounts.setTimestamp(0);

CreateAccountResultBatch accountErrors = client.createAccounts(accounts);
// Error handling omitted.
```

See details for the recommended ID scheme in
[time-based identifiers](https://docs.tigerbeetle.com/coding/data-modeling#tigerbeetle-time-based-identifiers-recommended).

The 128-bit fields like `id` and `user_data_128` have a few
overrides to make it easier to integrate. You can either
pass in a long, a pair of longs (least and most
significant bits), or a `byte[]`.

There is also a `com.tigerbeetle.UInt128` helper with static
methods for converting 128-bit little-endian unsigned integers
between instances of `long`, `java.util.UUID`, `java.math.BigInteger` and `byte[]`.

The fields for transfer amounts and account balances are also 128-bit,
but they are always represented as a `java.math.BigInteger`.

### Account Flags

The account flags value is a bitfield. See details for
these flags in the [Accounts
reference](https://docs.tigerbeetle.com/reference/account#flags).

To toggle behavior for an account, combine enum values stored in the
`AccountFlags` object with bitwise-or:

* `AccountFlags.LINKED`
* `AccountFlags.DEBITS_MUST_NOT_EXCEED_CREDITS`
* `AccountFlags.CREDITS_MUST_NOT_EXCEED_CREDITS`
* `AccountFlags.HISTORY`

For example, to link two accounts where the first account
additionally has the `debits_must_not_exceed_credits` constraint:

```java
AccountBatch accounts = new AccountBatch(2);

accounts.add();
accounts.setId(100);
accounts.setLedger(1);
accounts.setCode(718);
accounts.setFlags(AccountFlags.LINKED | AccountFlags.DEBITS_MUST_NOT_EXCEED_CREDITS);

accounts.add();
accounts.setId(101);
accounts.setLedger(1);
accounts.setCode(718);
accounts.setFlags(AccountFlags.HISTORY);

CreateAccountResultBatch accountErrors = client.createAccounts(accounts);
// Error handling omitted.
```

### Response and Errors

The response is an empty array if all accounts were
created successfully. If the response is non-empty, each
object in the response array contains error information
for an account that failed. The error object contains an
error code and the index of the account in the request
batch.

See all error conditions in the [create_accounts
reference](https://docs.tigerbeetle.com/reference/requests/create_accounts).

```java
AccountBatch accounts = new AccountBatch(3);

accounts.add();
accounts.setId(102);
accounts.setLedger(1);
accounts.setCode(718);
accounts.setFlags(AccountFlags.NONE);

accounts.add();
accounts.setId(103);
accounts.setLedger(1);
accounts.setCode(718);
accounts.setFlags(AccountFlags.NONE);

accounts.add();
accounts.setId(104);
accounts.setLedger(1);
accounts.setCode(718);
accounts.setFlags(AccountFlags.NONE);

CreateAccountResultBatch accountErrors = client.createAccounts(accounts);
while (accountErrors.next()) {
    switch (accountErrors.getResult()) {
        case Exists:
            System.err.printf("Batch account at %d already exists.\n",
                    accountErrors.getIndex());
            break;

        default:
            System.err.printf("Batch account at %d failed to create %s.\n",
                    accountErrors.getIndex(), accountErrors.getResult());
            break;
    }
}
```

## Account Lookup

Account lookup is batched, like account creation. Pass
in all IDs to fetch. The account for each matched ID is returned.

If no account matches an ID, no object is returned for
that account. So the order of accounts in the response is
not necessarily the same as the order of IDs in the
request. You can refer to the ID field in the response to
distinguish accounts.

```java
IdBatch ids = new IdBatch(2);
ids.add(100);
ids.add(101);

AccountBatch accounts = client.lookupAccounts(ids);
```

## Create Transfers

This creates a journal entry between two accounts.

See details for transfer fields in the [Transfers
reference](https://docs.tigerbeetle.com/reference/transfer).

```java
TransferBatch transfers = new TransferBatch(1);

transfers.add();
transfers.setId(UInt128.id());
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setUserData128(0, 0);
transfers.setUserData64(0);
transfers.setUserData32(0);
transfers.setTimeout(0);
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.NONE);
transfers.setTimeout(0);

CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
// Error handling omitted.
```

See details for the recommended ID scheme in
[time-based identifiers](https://docs.tigerbeetle.com/coding/data-modeling#tigerbeetle-time-based-identifiers-recommended).

### Response and Errors

The response is an empty array if all transfers were created
successfully. If the response is non-empty, each object in the
response array contains error information for a transfer that
failed. The error object contains an error code and the index of the
transfer in the request batch.

See all error conditions in the [create_transfers
reference](https://docs.tigerbeetle.com/reference/requests/create_transfers).

```java
TransferBatch transfers = new TransferBatch(3);

transfers.add();
transfers.setId(1);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);

transfers.add();
transfers.setId(2);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);

transfers.add();
transfers.setId(3);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);

CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
while (transferErrors.next()) {
    switch (transferErrors.getResult()) {
        case ExceedsCredits:
            System.err.printf("Batch transfer at %d already exists.\n",
                    transferErrors.getIndex());
            break;

        default:
            System.err.printf("Batch transfer at %d failed to create: %s\n",
                    transferErrors.getIndex(), transferErrors.getResult());
            break;
    }
}
```

## Batching

TigerBeetle performance is maximized when you batch
API requests.
A client instance shared across multiple threads/tasks can automatically
batch concurrent requests, but the application must still send as many events
as possible in a single call.
For example, if you insert 1 million transfers sequentially, one at a time,
the insert rate will be a *fraction* of the potential, because the client will
wait for a reply between each one.

```java
ResultSet dataSource = null; /* Loaded from an external source. */;
while(dataSource.next()) {
    TransferBatch batch = new TransferBatch(1);

    batch.add();
    batch.setId(dataSource.getBytes("id"));
    batch.setDebitAccountId(dataSource.getBytes("debit_account_id"));
    batch.setCreditAccountId(dataSource.getBytes("credit_account_id"));
    batch.setAmount(dataSource.getBigDecimal("amount").toBigInteger());
    batch.setLedger(dataSource.getInt("ledger"));
    batch.setCode(dataSource.getInt("code"));

    CreateTransferResultBatch transferErrors = client.createTransfers(batch);
    // Error handling omitted.
}
```

Instead, **always batch as much as you can**.
The maximum batch size is set in the TigerBeetle server. The default is 8189.

```java
ResultSet dataSource = null; /* Loaded from an external source. */;

var BATCH_SIZE = 8189;
TransferBatch batch = new TransferBatch(BATCH_SIZE);
while(dataSource.next()) {
    batch.add();
    batch.setId(dataSource.getBytes("id"));
    batch.setDebitAccountId(dataSource.getBytes("debit_account_id"));
    batch.setCreditAccountId(dataSource.getBytes("credit_account_id"));
    batch.setAmount(dataSource.getBigDecimal("amount").toBigInteger());
    batch.setLedger(dataSource.getInt("ledger"));
    batch.setCode(dataSource.getInt("code"));

    if (batch.getLength() == BATCH_SIZE) {
        CreateTransferResultBatch transferErrors = client.createTransfers(batch);
        // Error handling omitted.

        // Reset the batch for the next iteration.
        batch.beforeFirst();
    }
}

if (batch.getLength() > 0) {
    // Send the remaining items.
    CreateTransferResultBatch transferErrors = client.createTransfers(batch);
    // Error handling omitted.
}

```

### Queues and Workers

If you are making requests to TigerBeetle from workers
pulling jobs from a queue, you can batch requests to
TigerBeetle by having the worker act on multiple jobs from
the queue at once rather than one at a time. i.e. pulling
multiple jobs from the queue rather than just one.

## Transfer Flags

The transfer `flags` value is a bitfield. See details for these flags in
the [Transfers
reference](https://docs.tigerbeetle.com/reference/transfer#flags).

To toggle behavior for an account, combine enum values stored in the
`TransferFlags` object with bitwise-or:

* `TransferFlags.NONE`
* `TransferFlags.LINKED`
* `TransferFlags.PENDING`
* `TransferFlags.POST_PENDING_TRANSFER`
* `TransferFlags.VOID_PENDING_TRANSFER`

For example, to link `transfer0` and `transfer1`:

```java
TransferBatch transfers = new TransferBatch(2);

// First transfer
transfers.add();
transfers.setId(4);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.LINKED);

transfers.add();
transfers.setId(5);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.NONE);

CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
// Error handling omitted.
```

### Two-Phase Transfers

Two-phase transfers are supported natively by toggling the appropriate
flag. TigerBeetle will then adjust the `credits_pending` and
`debits_pending` fields of the appropriate accounts. A corresponding
post pending transfer then needs to be sent to post or void the
transfer.

#### Post a Pending Transfer

With `flags` set to `post_pending_transfer`,
TigerBeetle will post the transfer. TigerBeetle will atomically roll
back the changes to `debits_pending` and `credits_pending` of the
appropriate accounts and apply them to the `debits_posted` and
`credits_posted` balances.

```java
TransferBatch transfers = new TransferBatch(1);

transfers.add();
transfers.setId(6);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.PENDING);

CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
// Error handling omitted.

transfers = new TransferBatch(1);

transfers.add();
transfers.setId(7);
transfers.setAmount(TransferBatch.AMOUNT_MAX);
transfers.setPendingId(6);
transfers.setFlags(TransferFlags.POST_PENDING_TRANSFER);

transferErrors = client.createTransfers(transfers);
// Error handling omitted.
```

#### Void a Pending Transfer

In contrast, with `flags` set to `void_pending_transfer`,
TigerBeetle will void the transfer. TigerBeetle will roll
back the changes to `debits_pending` and `credits_pending` of the
appropriate accounts and **not** apply them to the `debits_posted` and
`credits_posted` balances.

```java
TransferBatch transfers = new TransferBatch(1);

transfers.add();
transfers.setId(8);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(10);
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.PENDING);

CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
// Error handling omitted.

transfers = new TransferBatch(1);

transfers.add();
transfers.setId(9);
transfers.setAmount(0);
transfers.setPendingId(8);
transfers.setFlags(TransferFlags.VOID_PENDING_TRANSFER);

transferErrors = client.createTransfers(transfers);
// Error handling omitted.
```

## Create And Return Transfers

Additionally, you can create transfers and retrieve information
about the outcome, such as the transfer timestamp and the accounts' balances.

See details in [create_and_return_transfers reference](https://docs.tigerbeetle.com/reference/requests/create_and_return_transfers).

```java
TransferBatch transfers = new TransferBatch(2);

transfers.add();
transfers.setId(10);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setAmount(99);
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.PENDING);

transfers.add();
transfers.setId(11);
transfers.setDebitAccountId(102);
transfers.setCreditAccountId(103);
transfers.setPendingId(10);
transfers.setAmount(TransferBatch.AMOUNT_MAX); // The actual amount depends on the pending transfer.
transfers.setLedger(1);
transfers.setCode(1);
transfers.setFlags(TransferFlags.POST_PENDING_TRANSFER);

CreateAndReturnTransferResultBatch transfersOutcome = client.createAndReturnTransfers(transfers);
while (transfersOutcome.next()) {
    System.out.printf("Transfer result: %s\n", transfersOutcome.getResult());

    if (CreateAndReturnTransferResultFlags.hasTransferSet(transfersOutcome.getFlags())) {
        System.out.printf("Transfer timestamp: %d amount: %s\n",
            transfersOutcome.getTimestamp(), transfersOutcome.getAmount());
    }

    if (CreateAndReturnTransferResultFlags.hasAccountBalancesSet(transfersOutcome.getFlags())) {
        System.out.printf("Debit account debits pending: %s\n", transfersOutcome.getDebitAccountDebitsPending());
        System.out.printf("Debit account debits posted: %s\n", transfersOutcome.getDebitAccountDebitsPosted());
        System.out.printf("Debit account credits pending: %s\n", transfersOutcome.getDebitAccountCreditsPending());
        System.out.printf("Debit account credits posted: %s\n", transfersOutcome.getDebitAccountCreditsPosted());

        System.out.printf("Credit account debits pending: %s\n", transfersOutcome.getCreditAccountDebitsPending());
        System.out.printf("Credit account debits posted: %s\n", transfersOutcome.getCreditAccountDebitsPosted());
        System.out.printf("Credit account credits pending: %s\n", transfersOutcome.getCreditAccountCreditsPending());
        System.out.printf("Credit account credits posted: %s\n", transfersOutcome.getCreditAccountCreditsPosted());
    }
}
```

## Transfer Lookup

NOTE: While transfer lookup exists, it is not a flexible query API. We
are developing query APIs and there will be new methods for querying
transfers in the future.

Transfer lookup is batched, like transfer creation. Pass in all `id`s to
fetch, and matched transfers are returned.

If no transfer matches an `id`, no object is returned for that
transfer. So the order of transfers in the response is not necessarily
the same as the order of `id`s in the request. You can refer to the
`id` field in the response to distinguish transfers.

```java
IdBatch ids = new IdBatch(2);
ids.add(1);
ids.add(2);

TransferBatch transfers = client.lookupTransfers(ids);
```

## Get Account Transfers

NOTE: This is a preview API that is subject to breaking changes once we have
a stable querying API.

Fetches the transfers involving a given account, allowing basic filter and pagination
capabilities.

The transfers in the response are sorted by `timestamp` in chronological or
reverse-chronological order.

```java
AccountFilter filter = new AccountFilter();
filter.setAccountId(2);
filter.setUserData128(0); // No filter by UserData.
filter.setUserData64(0);
filter.setUserData32(0);
filter.setCode(0); // No filter by Code.
filter.setTimestampMin(0); // No filter by Timestamp.
filter.setTimestampMax(0); // No filter by Timestamp.
filter.setLimit(10); // Limit to ten transfers at most.
filter.setDebits(true); // Include transfer from the debit side.
filter.setCredits(true); // Include transfer from the credit side.
filter.setReversed(true); // Sort by timestamp in reverse-chronological order.

TransferBatch transfers = client.getAccountTransfers(filter);
```

## Get Account Balances

NOTE: This is a preview API that is subject to breaking changes once we have
a stable querying API.

Fetches the point-in-time balances of a given account, allowing basic filter and
pagination capabilities.

Only accounts created with the flag
[`history`](https://docs.tigerbeetle.com/reference/account#flagshistory) set retain
[historical balances](https://docs.tigerbeetle.com/reference/requests/get_account_balances).

The balances in the response are sorted by `timestamp` in chronological or
reverse-chronological order.

```java
AccountFilter filter = new AccountFilter();
filter.setAccountId(2);
filter.setUserData128(0); // No filter by UserData.
filter.setUserData64(0);
filter.setUserData32(0);
filter.setCode(0); // No filter by Code.
filter.setTimestampMin(0); // No filter by Timestamp.
filter.setTimestampMax(0); // No filter by Timestamp.
filter.setLimit(10); // Limit to ten balances at most.
filter.setDebits(true); // Include transfer from the debit side.
filter.setCredits(true); // Include transfer from the credit side.
filter.setReversed(true); // Sort by timestamp in reverse-chronological order.

AccountBalanceBatch account_balances = client.getAccountBalances(filter);
```

## Query Accounts

NOTE: This is a preview API that is subject to breaking changes once we have
a stable querying API.

Query accounts by the intersection of some fields and by timestamp range.

The accounts in the response are sorted by `timestamp` in chronological or
reverse-chronological order.

```java
QueryFilter filter = new QueryFilter();
filter.setUserData128(1000); // Filter by UserData.
filter.setUserData64(100);
filter.setUserData32(10);
filter.setCode(1); // Filter by Code.
filter.setLedger(0); // No filter by Ledger.
filter.setTimestampMin(0); // No filter by Timestamp.
filter.setTimestampMax(0); // No filter by Timestamp.
filter.setLimit(10); // Limit to ten balances at most.
filter.setReversed(true); // Sort by timestamp in reverse-chronological order.

AccountBatch accounts = client.queryAccounts(filter);
```

## Query Transfers

NOTE: This is a preview API that is subject to breaking changes once we have
a stable querying API.

Query transfers by the intersection of some fields and by timestamp range.

The transfers in the response are sorted by `timestamp` in chronological or
reverse-chronological order.

```java
QueryFilter filter = new QueryFilter();
filter.setUserData128(1000); // Filter by UserData.
filter.setUserData64(100);
filter.setUserData32(10);
filter.setCode(1); // Filter by Code.
filter.setLedger(0); // No filter by Ledger.
filter.setTimestampMin(0); // No filter by Timestamp.
filter.setTimestampMax(0); // No filter by Timestamp.
filter.setLimit(10); // Limit to ten balances at most.
filter.setReversed(true); // Sort by timestamp in reverse-chronological order.

TransferBatch transfers = client.queryTransfers(filter);
```

## Linked Events

When the `linked` flag is specified for an account when creating accounts or
a transfer when creating transfers, it links that event with the next event in the
batch, to create a chain of events, of arbitrary length, which all
succeed or fail together. The tail of a chain is denoted by the first
event without this flag. The last event in a batch may therefore never
have the `linked` flag set as this would leave a chain
open-ended. Multiple chains or individual events may coexist within a
batch to succeed or fail independently.

Events within a chain are executed within order, or are rolled back on
error, so that the effect of each event in the chain is visible to the
next, and so that the chain is either visible or invisible as a unit
to subsequent events after the chain. The event that was the first to
break the chain will have a unique error result. Other events in the
chain will have their error result set to `linked_event_failed`.

```java
TransferBatch transfers = new TransferBatch(10);

// An individual transfer (successful):
transfers.add();
transfers.setId(1);
// ... rest of transfer ...
transfers.setFlags(TransferFlags.NONE);

// A chain of 4 transfers (the last transfer in the chain closes the chain with
// linked=false):
transfers.add();
transfers.setId(2); // Commit/rollback.
// ... rest of transfer ...
transfers.setFlags(TransferFlags.LINKED);
transfers.add();
transfers.setId(3); // Commit/rollback.
// ... rest of transfer ...
transfers.setFlags(TransferFlags.LINKED);
transfers.add();
transfers.setId(2); // Fail with exists
// ... rest of transfer ...
transfers.setFlags(TransferFlags.LINKED);
transfers.add();
transfers.setId(4); // Fail without committing
// ... rest of transfer ...
transfers.setFlags(TransferFlags.NONE);

// An individual transfer (successful):
// This should not see any effect from the failed chain above.
transfers.add();
transfers.setId(2);
// ... rest of transfer ...
transfers.setFlags(TransferFlags.NONE);

// A chain of 2 transfers (the first transfer fails the chain):
transfers.add();
transfers.setId(2);
// ... rest of transfer ...
transfers.setFlags(TransferFlags.LINKED);
transfers.add();
transfers.setId(3);
// ... rest of transfer ...
transfers.setFlags(TransferFlags.NONE);
// A chain of 2 transfers (successful):
transfers.add();
transfers.setId(3);
// ... rest of transfer ...
transfers.setFlags(TransferFlags.LINKED);
transfers.add();
transfers.setId(4);
// ... rest of transfer ...
transfers.setFlags(TransferFlags.NONE);

CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
// Error handling omitted.
```

## Imported Events

When the `imported` flag is specified for an account when creating accounts or
a transfer when creating transfers, it allows importing historical events with
a user-defined timestamp.

The entire batch of events must be set with the flag `imported`.

It's recommended to submit the whole batch as a `linked` chain of events, ensuring that
if any event fails, none of them are committed, preserving the last timestamp unchanged.
This approach gives the application a chance to correct failed imported events, re-submitting
the batch again with the same user-defined timestamps.

```java
// External source of time
long historicalTimestamp = 0L;
ResultSet historicalAccounts = null; // Loaded from an external source;
ResultSet historicalTransfers = null ; // Loaded from an external source.

var BATCH_SIZE = 8189;

// First, load and import all accounts with their timestamps from the historical source.
AccountBatch accounts = new AccountBatch(BATCH_SIZE);
while (historicalAccounts.next()) {
    // Set a unique and strictly increasing timestamp.
    historicalTimestamp += 1;

    accounts.add();
    accounts.setId(historicalAccounts.getBytes("id"));
    accounts.setLedger(historicalAccounts.getInt("ledger"));
    accounts.setCode(historicalAccounts.getInt("code"));
    accounts.setTimestamp(historicalTimestamp);

    // Set the account as `imported`.
    // To ensure atomicity, the entire batch (except the last event in the chain)
    // must be `linked`.
    if (accounts.getLength() < BATCH_SIZE) {
        accounts.setFlags(AccountFlags.IMPORTED | AccountFlags.LINKED);
    } else {
        accounts.setFlags(AccountFlags.IMPORTED);

        CreateAccountResultBatch accountsErrors = client.createAccounts(accounts);
        // Error handling omitted.

        // Reset the batch for the next iteration.
        accounts.beforeFirst();
    }
}

if (accounts.getLength() > 0) {
    // Send the remaining items.
    CreateAccountResultBatch accountsErrors = client.createAccounts(accounts);
    // Error handling omitted.
}

// Then, load and import all transfers with their timestamps from the historical source.
TransferBatch transfers = new TransferBatch(BATCH_SIZE);
while (historicalTransfers.next()) {
    // Set a unique and strictly increasing timestamp.
    historicalTimestamp += 1;

    transfers.add();
    transfers.setId(historicalTransfers.getBytes("id"));
    transfers.setDebitAccountId(historicalTransfers.getBytes("debit_account_id"));
    transfers.setCreditAccountId(historicalTransfers.getBytes("credit_account_id"));
    transfers.setAmount(historicalTransfers.getBigDecimal("amount").toBigInteger());
    transfers.setLedger(historicalTransfers.getInt("ledger"));
    transfers.setCode(historicalTransfers.getInt("code"));
    transfers.setTimestamp(historicalTimestamp);

    // Set the transfer as `imported`.
    // To ensure atomicity, the entire batch (except the last event in the chain)
    // must be `linked`.
    if (transfers.getLength() < BATCH_SIZE) {
        transfers.setFlags(TransferFlags.IMPORTED | TransferFlags.LINKED);
    } else {
        transfers.setFlags(TransferFlags.IMPORTED);

        CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
        // Error handling omitted.

        // Reset the batch for the next iteration.
        transfers.beforeFirst();
    }
}

if (transfers.getLength() > 0) {
    // Send the remaining items.
    CreateTransferResultBatch transferErrors = client.createTransfers(transfers);
    // Error handling omitted.
}

// Since it is a linked chain, in case of any error the entire batch is rolled back and can be retried
// with the same historical timestamps without regressing the cluster timestamp.
```
